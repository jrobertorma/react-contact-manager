09/12/2020
Jajaja, perdí todas las notas anteriores (no me voy a acordar de todo T.T), porque borré todo el proyecto debido a que no jalaba (sospecho de la selección del lint-er) así que vamos a ver de qué va esta vaina.

REFLEXIONES SOBRE PROYECTOS REACT-FEATHERS-MONBODB
Normalmente harías una API con Express, en ese caso tendrías que armar los famosos modelos, sus métodos (lo que le hacen a la BD) y los endpoints asociados a los métodos para activar su función en la BD (un CRUD).

Pues Feathersjs acelera ese proceso 'a la' Laravel, ya ves que le pasabas la BD, los nombres de los modelos y ya solito hacía todo el crud de manera automática.

Entonces, 'recableando' un poco puedes usarlo para tu BD.

MongoDB es una BD que funciona con archivos, supongo guarda las cosas en algo parecido a JSON, ammm, pues lo instalas y así (https://docs.mongodb.com/manual/tutorial/install-mongodb-on-windows/).

También debes instalar feathersjs (https://docs.feathersjs.com/) y oooobviamente tener node, react y yarn (opcional) instalados.

Estuve peleándome full con las versiones del Node y el condenado Yarn que quiere checar todo (tal vez no fué la mejor idea instalarlo lol), pero ya quedó, sospecho que el proyecto anterior no jaló debido a que ejecuté el create-react-app antes de instalar yarn y por eso el 'yarn start' no jalaba, pero ahora sí.

BTW, yarn es un package manager (https://yarnpkg.com/), es decir una capa más al ya atascado de capas proceso de creación de apps (a veces no le veo sentido jaja, y en realidad es una herramienta pensada para proyectos con muchos módulos, dependencias y así por el estilo).

11/12/2020
Pasos 2.8, 2.9, y 2.10, funcionó (lol), falta construir el front :s.

12-14/12/2020
Pasos 3.1 y 3.2, yasta, falta redux :ss.

15-22/12/2020
Revisión de notas sobre redux, y pasos 4.1 y 4.2, estamos listos para llenar los archivos de redux.

23-25/12/2020
Archivos para redux y sus dependencias.

26-31/12/2020
Conectar redux y react, la conexión está lista. Se modificó el componente que pinta contactos, ahora tiene cards de react-ui.

01-04/01/2021
Conectar con la API y actualizar los archivos relacionados con 'fetchContacts'.

04-14/01/2021
Formulario (está densoooo T.T), desinstalamos semantic-ui-react y semantic-ui-css para usar Material-UI (verás las razones en las notas de los formularios).

15-19/01/2021
Reescribir componentes para material-ui

20-25/01/2021
Construcción de formulario y validación por el front-end y back-end

26-29/01/2021
Implementar funcionalidad del botón 'Actualizar'

30/01/2021
Implementar funcionalidad del botón 'Borrar'

31/01/2021
Documentar Proyecto 

SUMARIO PROYECTO CONTACTOS
	1. Crea el proyecto con create-react-app

	2. Crear API
		2.1 Instalar gobalmente feathers-cli
		
		2.2 Crear carpeta llamada 'backend' (o cualquier nombre lol) y mover la terminal a ese directorio
		
		2.3 Crear el servidor con 'feathers generate app' //Nota que aquí eliges el linter, elegí ESLint y mocha para testing (ni idea de qué sea mocha lol)
		
		2.4 Crear rutas y modelos para los contactos (a la Laravel) con 'feathers generate service' //eliges mongoose, contact, /contacts y mongodb://localhost:27017/backend
		
		2.5 Instalar extensión para validar emails con 'yarn add mongoose-type-email'
		
		2.6 Instalar nodemon para no tener que reiniciar el servidor cuando modifiques algo con 'yarn add nodemon --dev'
		
		2.7 Modificar backend/package.json en la línea start a "nodemon src/"
			"scripts": {
			    "test": "yarn run lint && yarn run mocha",
			    "lint": "eslint src/. test/. --config .eslintrc.json --fix",
			    "dev": "nodemon src/",
			    "start": "node src/", /* se pasa a => "nodemon src/" */
			    "mocha": "mocha test/ --recursive --exit"
			  },
		
		2.8 Configurar la conexión a la BD en /backend/config/default.json
		
		2.9 Configurar modelos, para contact defines las propiedades que tendrán los "objetos" contacto, a saber: nombre, email, teléfono y fechas de creación y última modificación, esto se hace en backend/srs/models/contact.model.js (ese es el modelo que se creó con 'feathers generate service', revísalo en el commit para ver cómo quedó)
		
		2.10 Ya puedes testear el endpoint para 'contacts' en 'http://localhost:3030/contacts', y si le pasas un POST con los datos adecuados (con postman) los crea en la BD (:o, feathers simplifica full las cosas XD), estamos listos para hacer el front-end y llamar a los endpoints desde react.

		El cuerpo de la request debe llevar esto:

			{
			  "name": {
			    "first": "Joe",
			    "last": "BTO"
			  },
			  "phone": "+5555555555",
			  "email": "joe@merengues.com"
			}

		Notas sobre API: Con un comando ('generate service'), Feathers hace todo el trabajo para armar un modelo y su CRUD (revisa su documentación), obviamente hay que hacer cambios (véase punto 2.10) pero ya te ayuda con buena parte del trabajo.
		Puedes agregar tantos servicios, modelos y funciones como necesites, aunque para efectos didácticos (supongo), el libro solo muestra este ejemplo, de todos modos basta para hacer los demás si hacen falta, aquí termina la sección de la API.

	3. Crear Front-End
		3.1 Instalar dependencias para front-end (supongo son una especie de bootstrap para react, yeiii, una capa más ahora sobre la sintáxis al crear componentes T.T, por cierto que instalas en la raíz del proyecto (no en /backend))
			3.1.1 Instalar SemanticUI con 'yarn add semantic-ui-react semantic-ui-css' (https://react.semantic-ui.com/usage)
				IMPORTANTE: Ya no vamos a usar SemanticUI, lo sustituiremos por Material-UI (https://material-ui.com/getting-started/installation/)
				'yarn add @material-ui/core'
			3.1.2 Instalar react-router (lo usamos en el clon de reddit) con 'yarn add react-router-dom' (https://reactrouter.com/web/guides/quick-start)
		
		3.2 Agregar componentes para mostrar los contactos (un 'reporte') y para recibirlos/guardarlos (un 'insert/update').
			La 'arquitectura' de la app va así:
 			
 			index.js --> App.js
               --> ContactListPage (pages/contact-list-page, la lista de contactos)
                   --> Pinta unos textos y llama a ContactList (/components/contact-list), es un componente porque va a tener states (creo lol)
               --> ContactFormPage (/contacts/new, agregar nuevo contacto)
                   --> Pinta algún texto y llama a ContactForm (/components/contact-form), va a ser componente controlado porque es un formulario
               --> ContactFormPage (aún no se pinta, pero es la ruta para actualizar contactos, llama al mismo form (de ahí el mismo nombre de componente))
                   --> Es el mismo component de /contacts/new

		3.3 Instalar Redux (para gestión del estado, https://redux.js.org/introduction/getting-started), redux-promise-middleware (para ahorrarte trabajo con el 'handling' de los action, https://www.npmjs.com/package/redux-promise-middleware) y redux-thunk (para hacer solicitudes asíncronas a la API, https://github.com/reduxjs/redux-thunk)
			yarn add redux react-redux redux-promise-middleware redux-thunk 
		
		3.4 Para hacer las requests vamos a usar Axios(https://www.npmjs.com/package/axios) y para supervisar el comportamiento del store y las llamadas a 'dispatch' usaremos redux-devtools (https://www.npmjs.com/package/redux-devtools-extension, también instala su extensión en tu browser)
			yarn add redux-devtools-extension axios
		
		3.5 Crear archivos para ingregar redux con react
			contact-data.js /*Tiene un array (llamado 'contacts') con objetos 'contacto' (id, name, phone, email), ahorita está hardcodeado para hacer pruebas*/
			
			actions/contact-actions.js /*Exporta una función (fetchContacts()) que puede ser llamada asíncronamente para traerse los valores de contact-data y pasarlos al reducer (reducers/contact-reducer), incluye el action creator y el dispatch, solo hay que llamarla*/
			
			reducers/contact-reducer /*Función reducer para los contactos, el primer caso es el que cacha el action type FETCH_CONTACTS, que concatena al estado los valores que retorne la función fetchContacts()*/

			reducers/index.js /*concatena los reducers y los exporta listos para pasarlos al store*/

			store.js /* Creación del store */

			index.js /* Agregar store al componente <App/> para poder usarlo en todos lados*/

	4. Cablear Front-end y Back-end
		4.1 Agregar redux a los componentes, se usa la función 'connect()' de redux que recibe como parámetros las funciones 'mapStateToProps()' y 'mapDispatchToProps()' y el componente a integrar con redux.
			4.1.1 El primer componente en ser integrado es pages/contact-list-page.js, que se creó en el punto 3.2, ver comentario y notas en 'SOBRE CABLEADO REACT-REDUX'

		4.2 Configurar Axios para conectarse con el back-end, a fin de poder conectarnos con la BD e implementar un CRUD sobre ella.
			archivo actions/index.js (es la conexión, 'a la' PHP)

		4.3 Actualizar componentes y reducer para llamar a la API para el listado de los contactos
			4.3.1 actions/contact-actions.js ahora llama a la conexión creada en 4.2 y pasa a payload lo que retorna el endpoint de API '/contacts'
			4.3.2 reducers/contact-reducer.js ahora tiene un nuevo case para "FETCH_CONTACTS_FULFILLED" que hace mas o menos lo mismo que el primero

		4.4 Construir formulario para la creación de nuevos contactos (véanse las notas en 'SOBRE FORMULARIOS')
			4.4.1 Instalar 'react-final-form' (validación y gestión de formularios)		
				yarn add final-form react-final-form
				
			4.4.2 Llenar archivos empleados en el flujo de datos para 'formulario de nuevo contacto'
				contact-actions.js, ahora exporta dos nuevas funciones: newContact() y saveContact(contact), ambas incluyen el action creator y el dispatch en su definición (Los action types son: NEW_CONTACT, y SAVE_CONTACT respectivamente, debes cacharlos en la función reducer)
                
                contact-reducer.js, ahora tiene los casos adecuados para las action creadas en el paso anterior
                
                ContactForm (/components/contact-form) ahora tiene el layout de un formulario (react-final-form + material-ui), y validación poderosa (usando yup + react-final-form), y llama a axios para insertar en la BD.

            4.4.3 Implementar 'Actualización' de contactos
            	Se hizo sin redux, con un formulario único para update que en el handler tiene una llamada PUT a axios y que es llenado automáticamente por medio de props y llamadas a la API en componentDidMount(); 

            4.4.4 Implementar 'Borrado' de contactos
            	Se hizo con redux. 

		Notas sobre integración:
		
			SOBRE REDUX
			Redux es un framework de administración de estado para aplicaciones javascript. En redux tienes solo un contenedor de estados (store) para toda la aplicación (y solo uno). 

			Al ser un administrador de estado, redux puede lidiar con la modificación de una parte del estado (e.g. cambiar el teléfono de un usuario). En redux, todos los cambios de estado son efectuados al enviar (dispatch) una acción (action) al store (contenedor del estado).

			Las actions pueden verse como 'mensajeros' que llevan la información de los eventos que suceden en la app al store, luego, el store se encarga de actualizar su estado en función del 'mensaje' de la action. Los action son objetos que deben llevar la llave 'type' y opcionalmente más datos.

				const action = {
				  type: 'LOGIN'
				}

			para pasarlos al store (y que pueda encargarse de los cambios) se usan los 'action creators'. Un action creator es una función que retorna un action. 

				// Action creator
				function actionCreator(){ return action };

			luego usas el método 'dispatch' del store para entregárselo y que haga la operación sobre el estado indicada por el valor de la llave 'type' del action.

				const store = Redux.createStore(
				  (state = {login: false}) => state
				);
				const loginAction = () => {
				  return {
				    type: 'LOGIN'
				  }
				};
				// Dispatch the action here:
				store.dispatch(loginAction());

			Una vez hecho el dispatch, el store debe saber qué hacer con el 'action' indicado, para eso se usan los 'reducer', un reducer es una función pura (no cambia nada en términos globales, solo sus argumentos) que recibe un 'state' un 'action' y retorna un nuevo 'state'. 

			Las funciones reducer siempre deben retornar una nueva versión del estado y nunca modificarlo directamente.

			  const defaultState = {
			    authenticated: false
			  };//state
			  
			  //función reducer, nota cómo recibe el state y puede recibir un action
			  //también tiene un switch con los action que puede recibir y qué hacer en cada caso 
			  const authReducer = (state = defaultState, action) => {
			    switch ( action.type ){
			      case "LOGIN":
			        return {
			          authenticated: true
			        };
			  
			      case "LOGOUT":
			        return {
			          authenticated: false
			        };
			  
			      default:
			        return defaultState;
			    }
			  };
			  
			  //nota que el createStore llama a la función reducer (authReducer)
			  //así cuando llames a 'dispatch' (método del store) ya tienes enlazado el reducer y con él el estado
			  const store = Redux.createStore(authReducer);
			  
			  //action creators
			  const loginUser = () => {
			    return {
			      type: 'LOGIN'
			    }
			  };
			  
			  const logoutUser = () => {
			    return {
			      type: 'LOGOUT'
			    }
			  };

			El store también tiene el método 'subscribe', que llama a una función cada vez que el estado cambia

			  	const ADD = 'ADD';

				const reducer = (state = 0, action) => {
				  switch(action.type) {
				    case ADD:
				      return state + 1;
				    default:
				      return state;
				  }
				};

				const store = Redux.createStore(reducer);

				// global count variable:
				let count = 0;

				// función que incrementa la variable count, aquí puede ir lo que sea lol
				const addOne = () => (count += 1);

				//subscribe de la función addOne al store
				store.subscribe( addOne );

				//cada vez que cambie el estado (véase el 'dispatch') se llama a addOne por el 'subscribe'
				store.dispatch({type: ADD});
				console.log(count);
				store.dispatch({type: ADD});
				console.log(count);
				store.dispatch({type: ADD});
				console.log(count);

			Para lidiar con estados complejos puedes crear múltiples funciones 'reducer' y luego concatenarlas para pasárselas a createStore
			(recuerda que solo puede haber un estado), el método para hacerlo es combineReducers (makes sense lol).

			Es buena práctica crear un reducer por cada pieza del estado que sea distinta de las otras de alguna manera. e.g. En una app de notas con autenticación de usuarios un reducer puede lidiar con la autenticación mientras otro se encarga de las notas (objeto usuario y objeto nota son fundamentalmente distintos, en keys y sus respectivos valores), en ese caso podríamos combinar los reducers así:

				//authenticationReducer y notesReducer son reducers como los declarados en los ejemplos anteriores
				const rootReducer = Redux.combineReducers({
				  auth: authenticationReducer,
				  notes: notesReducer
				});

			Otro ejemplo ;):

				const INCREMENT = 'INCREMENT';
				const DECREMENT = 'DECREMENT';

				const counterReducer = (state = 0, action) => {
				  switch(action.type) {
				    case INCREMENT:
				      return state + 1;
				    case DECREMENT:
				      return state - 1;
				    default:
				      return state;
				  }
				};

				const LOGIN = 'LOGIN';
				const LOGOUT = 'LOGOUT';

				const authReducer = (state = {authenticated: false}, action) => {
				  switch(action.type) {
				    case LOGIN:
				      return {
				        authenticated: true
				      }
				    case LOGOUT:
				      return {
				        authenticated: false
				      }
				    default:
				      return state;
				  }
				};

				/*Aquí combinas los reducers como elementos del nuevo reducer
				  nota que las const que los contienen nunca son llamadas por createStore
				*/
				const rootReducer = Redux.combineReducers(
				  {
				    count: counterReducer,
				    auth: authReducer
				  }
				);

				const store = Redux.createStore(rootReducer);

			También puedes pasarle parámetros a los reducers para hacer cosas como handling de entrada de usuario y así.

				const ADD_NOTE = 'ADD_NOTE';

				const notesReducer = (state = 'Initial State', action) => {
				  switch(action.type) {
				    /* Se cacha la acción y se retorna el dato (léase entrada de usuario) como prop del parámetro action
				       véase action.text */
				    case ADD_NOTE:
				    	return  action.text

				    default:
				    	return state;
				  }
				};

				const addNoteText = (note) => {
				  return {type: ADD_NOTE, text: note}; //el action creator retorna la action tipo ADD_NOTE y pasa un parámetro al reducer
				};

				const store = Redux.createStore(notesReducer);

				console.log(store.getState());
				store.dispatch(addNoteText('Hello!')); //le pasas al action creator un parámetro ('Hello!')
				console.log(store.getState());

		Eventualmente vas a necesitar hacer llamadas asíncronas a algún recurso (sea una BD, una API, o por el estilo), para lograrlo vas a necesitar un 'middleware' diseñado para ese propósito, en este caso usaremos 'Redux Thunk'

		Para incluir 'Redux Thunk' al store, lo pasas como argumento al método applyMiddleware() y a su vez, lo agregas como segundo parámetro a createStore().

			const store = Redux.createStore(
			  asyncDataReducer, //la función reducer
			  Redux.applyMiddleware(ReduxThunk.default) //segundo parámetro con el middleware redux thunk
			);

		Luego, para crear las acciones asíncronas, usas un action creator que retorne una función que reciba 'dispatch' como argumento (lol), dentro de esa función puedes hacer dispatch a otras acciones y hacer solicitudes asíncronas a los recursos de terceros.

			//action creator que retorna una función que recibe dispatch como argumento
			const handleAsync = () => {
			  return function(dispatch) {
			    // dispatch request action here
			    dispatch(requestingData()); //recuerda que los dispatch reciben action creators con la llave 'type'
			    							// lo que le permite saber al reducer qué hacer con el estado

			    setTimeout(function() {
			      //el setTimeout simula la solicitud asíncrona que devuelve los valores de 'data'
			      let data = {
			        users: ['Jeff', 'William', 'Alice']
			      }
			      dispatch(receivedData(data)); //llamas a dispatch y le pasas un action creator distinto
			      								//en este caso puede ser el que actualiza el estado para pintar a 'data'
			      								//nota que le pasa 'data' como parámetro, lo que indica que el reducer va a usar esos datos
			    }, 2500);
			  }
			};

		SOBRE EL CREATE STORE DEL PROYECTO
		Usamos redux dev tools, en su documentación está este ejemplo de configuración inicial:

			import { createStore, applyMiddleware } from 'redux';
			import { composeWithDevTools } from 'redux-devtools-extension';

			const store = createStore(reducer, composeWithDevTools(
			  applyMiddleware(...middleware),
			  // other store enhancers if any
			));

		Y es más o menos lo que el libro traía:

			import { applyMiddleware, createStore } from "redux";
			import thunk from "redux-thunk";
			import promise from "redux-promise-middleware";
			import { composeWithDevTools } from "redux-devtools-extension"
			import rootReducer from "./reducers";

			const middleware = composeWithDevTools(applyMiddleware(promise(),thunk))

			export default createStore(rootReducer,middleware);

		Nota la constante middleware que con composeWithDevTools() invoca los middleware que vamos a usar; promise y thunk,
		luego se los pasa createStore() como segundo argumento, el primero es el stack de reducers de reducers/index.js (nota el import
		que no especifica la ruta completa, solo la carpeta './reducers', :o)

		Por cierto que el código da error XD, debes quitarle los paréntesis a 'promise()' para que funcione, en la documentación de redux-promise-middleware (https://github.com/pburtchaell/redux-promise-middleware/blob/HEAD/docs/introduction.md) está:

			import promise from 'redux-promise-middleware'

			composeStoreWithMiddleware = applyMiddleware(
			  promise,
			)(createStore);

		Que es otra sintáxis para crear stores, pero lo que nos interesa es que el argumento 'promise' de applyMiddleware no lleva los paréntesis de función, probé a quitárselos en el código y jaló :).

		SOBRE EL 'SPREAD OPERATOR'
		Es una 'sintáxis' que permite invocar todos los elementos de un elemento iterable (léase array o string), y modificarlo (o no) uno por uno.

		Es usada comúnmente para agregar un nuevo elemento a un contenedor de datos local (de nuevo un array) o pintar todos los valores del array
		más (+) un nuevo elemento.

		Un ejemplo (muy simple) de esto es:

			let numberStore = [0, 1, 2];
			let newNumber = 12;
			numberStore = [...numberStore, newNumber];
			//numberStore ahora es [0,1,2,12]

		Cada vez que llames la sintaxis con el spread operator (los tres puntos antes del nombre del array e.g.: ...numberStore)
		se va a agregar un 12 al final del array.

		Nota que se tuvo que hacer la asignación de numberStore a lo que retorne el 'spread operator', pues no modifica el array original
		(por eso se lleva bien con redux y la programación funcional en general).

		SOBRE CABLEADO REACT-REDUX
		En index.js habíamos habilitado redux como 'wrapper' de la app (el componente <Provider store={store}>), pero necesitas especificar qué partes del state y qué actions vas a ocupar en cada componente, para eso están las funciones mapStateToProps() y mapDispatchToProps(),

			function mapStateToProps( state ){
			   //Se recibe el state como argumento y se pasa como valor de la llave messages
			   //nota que solo es así para este caso, en teoría podrías decidir qué partes
			   //del state vas a pasar como props al componente
			  return { messages: state };
			}

		mapDispatchToProps(), Es usada para pasarle 'action creators' específicos a los componentes react para que puedan hacer sus dispatch asociados al store. Retorna un objeto que mapea los dispatch con props de componente react (de ahí el nombre lol), pero en vez de regresar una parte del estado (como mapStateToProps), cada prop retorna una función que llama el dispatch con su action creator y cualquier dato (argumento) necesario. 

			//La función recibe dispatch, para poder pasárlo a las props y que el componente pueda llamarlo
			function mapDispatchToProps( dispatch ){
			  //Va a regresar un objeto con la prop submitNewMessage (que será llamada desde el componente)
			  //y recibe el argumento(parámetro) message que a su vez ejecuta el dispatch (definido en otro lado XD)
			  return {
			  	submitNewMessage: function (message) {
			      					dispatch( addMessage(message) );
			    				  } 
			  };
			}

		Ahora con las funciones listas, puedes pasárselas a un componente react para que las use y así conectar react y redux (al fin XD), para eso sirve el método 'connect()' de redux (naturalmente tienes que importarlo), este método recibe tres argumentos, los primeros dos opcionales que son mapStateToProps y mapDispatchToProps, el tercero es el componente, los 'map' son opcionales porque puede que necesites un componente que solo traiga cosas del estado pero no dispatch o visceversa. La sintáxis eso sí, es un tanto atípica:

			 connect(mapStateToProps, mapDispatchToProps)(MyComponent)

		Si quieres omitir uno de los argumentos opcionales pasas 'null' en su lugar.

		Todo en un ejemplo se vería así:

		//Action creator
		const addMessage = (message) => {
		  return {
		    type: 'ADD',
		    message: message
		  }
		};

		//función mapstatetoprops (duh), para pasar el estado como una prop al componente
		const mapStateToProps = (state) => {
		  return {
		    messages: state
		  }
		};

		//función mapdispatchtoprops (duh again), para pasar actions como una prop al componente
		const mapDispatchToProps = (dispatch) => {
		  return {
		    submitNewMessage: (message) => {
		      dispatch(addMessage(message));
		    }
		  }
		};

		//definición del componente
		class Presentational extends React.Component {
		  constructor(props) {
		    super(props);
		  }
		  render() {
		    return <h3>This is a Presentational Component</h3>
		  }
		};

		const connect = ReactRedux.connect;

		//Conectando el componente, es importante pasarlo a una variable
		const ConnectedComponent = connect(mapStateToProps, mapDispatchToProps)(Presentational);

		Y ahora puedes usar las props definidas en las funciones map. Así puedes pintar datos en función del store redux y modificar el store desde el componente ;).

		SOBRE VALIDACIÓN DE TIPOS PARA PROPS
		En el libro a veces se valida que las props pasadas a un componente tengan ciertas propiedades (e.g. que la prop sea un objeto y que es requerida), googleando la sintáxis, la forma de hacer esto ha cambiado (https://es.reactjs.org/docs/typechecking-with-proptypes.html)

		Ahora debes instalar prop-types, (una más T.T).

			npm install --save prop-types
			
			or

			yarn add prop-types

		Luego la importas al componente

			import PropTypes from 'prop-types'; // ES6

		Y ya la puedes usar (véase la documentación, https://www.npmjs.com/package/prop-types).

		SOBRE AXIOS
		Axios es un cliente http basado en promesas que permite hacer 'requests' a servidores nodejs, es decir que hace el equivalente a GET, POST, etc. de PHP para entornos construidos sobre nodejs.

		https://www.npmjs.com/package/axios

		las request son full de legibles XD, ahora puedes incorporarlas a los dispatch para hacer el CRUD sobre la BD desde el front (:o), nota que hay que echar a andar todo, el servidor de BD (mongo), el servidor de la API (feathers) y la app react.

		SOBRE FORMULARIOS
		Todo método de entrada de usuario debe estar blindado tanto contra ataques maliciosos como contra usuarios despistados (lul), la forma más común para solucionar ambos casos en formularios es la validación de sus campos, cuando trabajas con un entorno API(backend) | UI(frontend), las entradas se deben validar en ambos lados. Las validaciones del lado del cliente permiten 'parsear' la entrada de usuario antes de que llame a nadie y también obligan al usuario a llenar los campos que necesite el desarrollador. El backend vuelve a parsear la entrada del usuario y lidia con la generación de errores, es necesario habilitar la comunicación entre ambas capas para que el usuario sepa qué está pasando con su entrada.

		Y como todo eso requiere mucho trabajo y es una tarea más o menos parecida entre todos los formularios, existen librerías que facilitan todo ese asunto.

		Redux-Form (antes, ahora vamos a usar 'React-final-form') y Classnames

		Classnames permite generar nombres de clases (really? haha) y agregarlas a componentes react dinámicamente, e.g. crear un nombre de clase para errores previamente contemplado en los estilos y así resaltar errores de entrada de usuario (https://www.npmjs.com/package/classnames).

		React-final-form es el heredero de redux-form y es la solución sugerida por su creador si estás desarrollando desde cero (sus motivos tendrá lol https://final-form.org/docs/react-final-form/philosophy). La verdad nos enfrentamos a una disyunción interesante, si usas redux-form podrás importar un reducer y gestionar ambos lados de la app, si optas por elegir react-final-form no podrás validar desde el backend, al menos de forma automática (revisa los docs).

		En la documentación dice que el único motivo por el cual desearías tener los datos del 'final-form' en redux, es si los necesitas disponibles 'afuera' del formulario, y hay 'artificios' para hacerlo, pero no podrás cambiar ni el estado, ni los datos en redux, ni los datos del formulario, si necesitas mutarlos mediante 'dispatchs' (mira ese plural) al store probablemente sea mejor que uses 'redux form'.

		No vamos a mutar las entradas nunca, pero sí necesitamos cachar (y generar) respuestas de error desde el backend.

		SOBRE REACT FINAL FORMS
		La librería ayuda a gestionar formularios, tiene un montón de cosas y formas de ser 'tuneada' (odio esa palabra), el caso es que sirve para nuestros propósitos, a saber, generar un formulario para el alta de contactos de la APP, debe validar las entradas del usuario y también las respuestas del Backend, y aquí entramos en territorios inexplorados porque el 'cómo' es distinto al del libro, encontré en la documentación dos ejemplos que nos pueden servir:

			1. Validación asíncrona de campos (https://codesandbox.io/s/wy7z7q5zx5?file=/index.js)
			2. Cachando errores del servidor (https://codesandbox.io/s/github/final-form/react-final-form/tree/master/examples/submission-errors?from-embed)

		Antes de revisarlos hay que entender la API de la librería:

			<Form/>, wrapper del formulario (no te lo esperabas, ha?), gestiona todo el estado del form y puede pasarle props (estados y funcionalidades) a sus hijos. Las dos props requeridas son onSubmit y una para pintar que puede ser component, render o children, la práctica recomendada es usar render para que no se pinte en el dom (y sea inspeccionable).

			onSubmit es una función que es llamada cuando se envía el formulario y pasa las validaciones (véase <Field/>) y recibe los valores del mismo (de sus campos).

			También pasa handleSubmit a la función render, este método está diseñado para ser pasado como el onSubmit del componente HTML <form>, y es que llama a e.preventDefault() para que no se recargue la página (old school is cool).

			En la práctica todos los formularios llevan esta estructura:

				<Form onSubmit={onSubmit}>
				  {props => (
				    <form onSubmit={props.handleSubmit}>

				      ... fields go here...

				      <button type="submit">Submit</button>
				    </form>
				  )}
				</Form>

			https://final-form.org/docs/react-final-form/api/Form

			En https://final-form.org/docs/react-final-form/types/FormProps están todas las props que puede recibir un formulario, entre las más usadas están:

				validate: opcional, debe ser una función que valida todos los campos y retorne errores de validación. Se puede escribir de manera asíncrona (usando promesas) o no (con un return a la old school).

				onSubmit: requerida, función llamada cuando el formulario se envía sin errores, puede ser asíncrona (promesas 'or' callbacks ) o no.

				render: Forma recomendada para pintar un formulario, recibe una arrow function que especifica los contenidos del formulario, recibe todas las props FormRenderProps así como todas las props que no sean de la API que se definieron en el componente <Form/>.

				<Form
				  onSubmit={onSubmit}
				  someArbitraryOtherProp={42} //non-API prop

				  //prop render, nota que recibe una 'arrow function'
				  render={props => {
				    console.log(props.someArbitraryOtherProp) // would print 42, es decir, puedes acceder a todas las props de <Form/>
				    return <form onSubmit={props.handleSubmit}> ... </form> //aquí se definen los campos y botones del formulario
				  }}
				/>

			<Field/>, registra un campo en el form que lo contiene, lo 'suscribe' al estado de los campos e 'inyecta' el estado y las funciones callback: onBlur, onChange, y onFocus por medio de una prop render.

			Para usar <Field/> necesitas tres cosas:
				1. Definir una prop 'name'
				2. Definir la forma de pintar el campo (similar a <Form/>, puedes pintar un HTML 'vanilla', un componente react, como componente input, etc.)
				3. Conectar las funciones 'callback' del campo con la entrada del usuario, depende del método elegido en el paso 2.
					<Field name="myField" component="input" />

					'or'

					<Field name="myField">
					  {props => (
					    <div>
					      <input {...props.input} />
					    </div>
					  )}
					</Field>

					'Or' a mano si estás usando una prop 'render'.

			En https://final-form.org/docs/react-final-form/api/Field están todas las props que pueden recibir, las más comunes son:

				name: obligatoria, el identificador del campo

				Una entre component, render, or children: obligatoria, para pintar el campo, se recomienda usar un componente, a la hora de pintar el campo hay que pasarle las variables input (entrada de usuario) y meta (usada para validar) para que funcione.

				<Field name="username">
	                {
	                //nota que es una arrow function (args) => {//function content}
	                ({ input, meta }) => (
	                <div>
	                    <label>Username</label>
	                    <input {...input} type="text" placeholder="Username" />
	                    {/* 'condition && <p>markup</p>', al parecer la condición trae un 'and' en el primer && 
	                        en pocas palabras, si encuentra valores en las dos variables meta, pinta el error en un <span>*/}
	                    {meta.error && meta.touched && <span>{meta.error}</span>}
	                </div>
	                )}
	            </Field>

	    SOBRE MATERIAL-UI
	    Encontré full de problemas para integrar react-final-form con SemanticUI, así que nos cambiamos a material-ui, el problema es que todo el layout existente se rompió, se tuvo que reescribir todo el código hasta la fecha (T.T), el primer obstáculo fué hacer que react-router se llevara con el menú de material UI, y aquí está el truco:

	    Cómo linkear react-router con menú de material-ui
	    	Lo primero es ver cómo son los menús: Además de tener un wrapper que define las propiedades del Menú (dato random, el wrapper es el componente <Menu>), debes definir los handler del botón que despliege los enlaces, porque igual que bootstrap, material-ui está diseñado con la filosofía 'mobile-first', el menú por default funciona parecido a los menús de apps móviles (un botoncito despliega los enlaces). Luego defines los enlaces y ya estás listo:

	    		import React from 'react';
				import Button from '@material-ui/core/Button';
				import Menu from '@material-ui/core/Menu';
				import MenuItem from '@material-ui/core/MenuItem';

				export default function SimpleMenu() {
				  //los handler del botón que despliegan el contenido del menú
				  const [anchorEl, setAnchorEl] = React.useState(null);

				  const handleClick = (event) => {
				    setAnchorEl(event.currentTarget);
				  };

				  const handleClose = () => {
				    setAnchorEl(null);
				  };

				  return (
				  	//El botón, nota el onClick que llama al handler definido arriba
				    <div>
				      <Button aria-controls="simple-menu" aria-haspopup="true" onClick={handleClick}>
				        Open Menu
				      </Button>

				      //Componente menú, con sus props, nota las props anchorEl, open y onClose
				      <Menu
				        id="simple-menu"
				        anchorEl={anchorEl}
				        keepMounted
				        open={Boolean(anchorEl)}
				        onClose={handleClose}
				      >
				      	//los items del menú, ignora el onClick porque lo vamos a sobreescribir para que funcione con react-router
				        <MenuItem onClick={handleClose}>Profile</MenuItem>
				        <MenuItem onClick={handleClose}>My account</MenuItem>
				        <MenuItem onClick={handleClose}>Logout</MenuItem>
				      </Menu>
				    </div>
				  );
				}

			Sigue la integración con react-router: Para eso viene bien la documentación sobre 'composición' (en las fuentes). Como puedes ver, el truco está en ponerle un 'alias' (así les digo yo lol, aludiendo a ese concepto en SQL) a el componente <Link> de react-router.

			No te olvides que en react-router, los componentes <Link> pintan el enlace y reciben la prop que le indica a router qué ruta pintar en el onClick
				...
				 <Router>
			      <div>
			        <ul>
			          <li>
			            <Link to="/">Home</Link> //Este es el Link de react-router
			          </li>
			   	...

			Pues que material-ui también tiene un componente <Link> aunque solo es un enlace bonito sin handlers ni nada, para agregarle las funcionalidades de react-router podemos usar la capacidad de 'composición' de los componentes de esa librería.

			En pocas palabras, le puedes decir al componente que pinte otro componente dentro de él y así puedes incorporar toda las funcionalidades de otros componentes a la UI bonita de los componentes de material-ui.

			Esto se ve así:

				/* eslint-disable jsx-a11y/anchor-is-valid */
				import React from 'react';
				import { MemoryRouter as Router } from 'react-router';
				import { Link as RouterLink } from 'react-router-dom'; //Nota el 'alias' del <Link> de react-router
				import Link from '@material-ui/core/Link'; //Nota que llamamos al <Link> de material-ui

				//no le hagas caso a esta, no la ocupamos
				const LinkBehavior = React.forwardRef((props, ref) => (
				  <RouterLink ref={ref} to="/getting-started/installation/" {...props} />
				));

				export default function LinkRouter() {
				  return (
				  	//wrapper de react-router
				    <Router>
				      <div>
				      	//Esto es lo que nos interesa, Link llama a RouterLink con la prop 'component' (checa el import arriba) y le pasa la ruta, 
				      	//luego la puedes definir en el switch de rutas e implementar la navegación completa.
				        <Link component={RouterLink} to="/">
				          With prop forwarding
				        </Link>
				        <br />
				        <Link component={LinkBehavior}>Without prop forwarding</Link>
				      </div>
				    </Router>
				  );
				}

			Para el proyecto que nos ocupa, el menú quedó así:

				//robado de los docs de material-ui lol
				function SimpleMenu() {
				  //handlers
				  const [anchorEl, setAnchorEl] = React.useState(null);

				  const handleClick = (event) => {
				    setAnchorEl(event.currentTarget);
				  };

				  const handleClose = () => {
				    setAnchorEl(null);
				  };

				  return (
				    <div>
				      //botón para desplegar los enlaces
				      <Button aria-controls="simple-menu" aria-haspopup="true" onClick={handleClick}>
				        Open Menu
				      </Button>

				      //el menú con sus props
				      <Menu
				        id="simple-menu"
				        anchorEl={anchorEl}
				        keepMounted
				        open={Boolean(anchorEl)}
				        onClose={handleClose}
				      >	
				      	/*aquí está el truco, nota como cada <MenuItem> llama a un <Link> de material-ui, que a su vez llama a un <RouterLink>,
				      	* que a su vez (XD) es un <Link> de react-router, y así puede llamar a las rutas definidas en el <Switch> de react-router
				      	*/
				        <MenuItem onClick={handleClose}> <Link component={RouterLink} to="/">Contacts List</Link> </MenuItem>
				        <MenuItem onClick={handleClose}> <Link component={RouterLink} to="/contacts/new">Add Contact</Link> </MenuItem>
				      </Menu>

				      /*Robado del ejemplo básico de react-router, aquí le dices al router qué rutas puede pintar y a quién llamar cuando haga
				      * falta
				      */
				      <Switch>
				        <Route exact path="/" component={ContactListPage}/>
				        <Route path="/contacts/new" component={ContactFormPage}/>
				        <Route path="/contacts/edit/:_id" component={ContactFormPage}/>
				      </Switch>
				    </div>
				  );
				}

    	Fuentes: 
    			https://material-ui.com/components/menus/
    			https://material-ui.com/guides/composition/
    			https://reactrouter.com/web/example/basic
    			https://youtu.be/rl4TgzcaLe0 (no garantizo que funcione siempre lol)

	    Luego está el hecho de que el layout original estaba en tabs, y la verdad me gustaba la idea de verla así, entonces cambiamos el menú (en pocas palabras todo el código anterior no se va a usar T.T) y pusimos la navegación principal en tabs.

	    Cómo integrar un layout de tabs (material-ui) con react-router
	    Las tab básicas funcionan así:

	    	<AppBar position="static"> //Es la barra con algún color en donde aparecen las tabs
			  <Tabs value={value} onChange={handleChange} aria-label="simple tabs example"> //contenedor de tabs
			    <Tab label="Item One" {...a11yProps(0)} /> //las tabs, nota que solo necesitan una label y reciben jsx (dentro de las {})
			    <Tab label="Item Two" {...a11yProps(1)} />
			    <Tab label="Item Three" {...a11yProps(2)} />
			  </Tabs>
			</AppBar>
			<TabPanel value={value} index={0}> //Aquí especificarías qué componente pintar
			  Item One
			</TabPanel>
			<TabPanel value={value} index={1}>
			  Item Two
			</TabPanel>

		Vamos a reemplazar <TabPanel> por react router, lo que quedaría así:

			<div className="App">
		      <BrowserRouter> //Como usaremos react-router, necesitas encerrar todo en browserRouter
		        <Route /* Pintas una ruta por default (véase la prop 'path'), 
		        	   *  nota cómo recibe una arrow function en la prop render, en esa función especificas todas las tabs
		        	   */
		          path="/"
		          render={(history) => (
		            <AppBar> //La barra de color
		              <Tabs /* contenedor de tabs, nota la prop value (requerida según la doc), que le permite a react saber qué 
		              		*  tab se está pintando por medio de la prop 'history', dicha prop es usable debido a que estamos pintando
		              		*  las tabs desde la prop 'render' de un componente <Route> (https://reactrouter.com/web/api/Route/render-func)
		              		*  al usar el historial del dom puedes decirle a Tabs, qué tab está siendo renderizada
		              		*  por eso el operador ternario: Si no estás pintando "/", 'value' será la ruta 'react-router' en la que estés
		              		*  si por otro lado estás en "/" entonces 'value' será 'false' y en las tabs no se va a resaltar nada.
		              		*  Por cierto que quité el operador en dev para que se resalte la tab en "/"
		              		*/
		                value={
		                  history.location.pathname !== "/"
		                    ? history.location.pathname
		                    : false
		                }
		              >
		                {console.log(history.location.pathname)}
		                <Tab /* las tab individuales, nota que usan la prop 'component' para llamar a un 'Link' de react-router, 
		                     *  estamos usando composición de componentes ;)
		                     */
		                  value={routes[0]}
		                  label="books"
		                  component={Link}
		                  to={routes[0]}
		                />
		                <Tab
		                  value={routes[1]}
		                  label="Favorites"
		                  component={Link}
		                  to={routes[1]}
		                />
		              </Tabs>
		            </AppBar>
		          )}
		        />

		       	//yyyy, en el switch defines los componentes a pintar según la ruta llamada
		        <Switch>
		          <Route path="/books" component={Books} />
		          <Route path="/favorites" component={Favorites} />
		        </Switch>
		      </BrowserRouter>
		    </div>

	    Usando el ejemplo anterior, el componente del menú quedó así (se asume que quien lo llame lo ponga dentro de una instancia de BrowserRouter):

		    function TabsMenu() {
			  const routes = ["/", "/contacts/new", "contacts/edit/:_id"];

			  return (
			    <Container className="App"> //container de material-ui
			      <Route
			        path="/"
			        render={(history) => (
			          <AppBar>
			            <Tabs
			              centered
			              value={
			                history.location.pathname !== "/"
			                  ? history.location.pathname
			                  : false
			              }
			            >
			              {/*console.log(history.location.pathname)*/}
			              <Tab
			                value={routes[0]}
			                label="Contacts"
			                component={RouterLink}
			                to={routes[0]}
			              />
			              <Tab
			                value={routes[1]}
			                label="Add Contact"
			                component={RouterLink}
			                to={routes[1]}
			              />
			            </Tabs>
			          </AppBar>
			        )}
			      />

			      <Switch>
			        <Route exact path="/" component={ContactListPage}/>
			        <Route path="/contacts/new" component={ContactFormPage}/>
			        <Route path="/contacts/edit/:_id" component={ContactFormPage}/>
			      </Switch>
			    </Container>
			  );
			}

	    	Fuentes:
	    			https://material-ui.com/components/tabs/
	    			https://stackoverflow.com/questions/41638688/material-uis-tabs-integration-with-react-router-4/41654699
	    			https://reactrouter.com/web/api/Route/render-func
	    			https://www.youtube.com/watch?v=voNhE4vNFa4 (videazo BTW)

	    Cómo modificar colores, tipografías y más en material-ui
	    Puedes usar los 'themes' para personalizar los componentes creados con material-ui (https://material-ui.com/customization/theming/)
	    Debes agregar 'styles' a las dependencias (https://material-ui.com/styles/basics/)

	    	yarn add @material-ui/styles (no es necesario XD)

	    Luego defines los estilos que necesites, primero vamos a probar los colores (https://material-ui.com/customization/color/#picking-colors) con:

	    	import { ThemeProvider, createMuiTheme } from '@material-ui/core/styles'
			import teal from '@material-ui/core/colors/teal';

			const greenTheme = createMuiTheme({
			  palette: {
			    primary: {
			      main: '#004d40',
			    },
			    secondary: teal,
			  },
			});

		Los agregas al wraper ThemeProvider para que encierre a toda la app 

			<ThemeProvider theme={greenTheme}>	

		Y listo.

		También puedes modificar los colores en componentes hijo con este método

			https://stackoverflow.com/questions/46486565/material-ui-next-customize-button-colors
			https://material-ui.com/customization/theming/
			https://material-ui.com/customization/color/#playground



	    SOBRE REACT-FINAL-FORM Y MATERIAL UI
	    Para integrar un formulario de final-form con los componentes bonitos de material ui necesitas otro paquete (bruhhhh, ya para).
	    Se trata de https://github.com/lookfirst/mui-rff, instalas todo con:
	    	
	    	yarn add mui-rff @material-ui/core @material-ui/pickers@3.x.x @material-ui/lab final-form react-final-form

	    Nota que va react-final-form, el core de material-ui, y alguna otra dependencia que no sé muy bien qué hace.

	    El uso sugerido de la librería está en la documentación (enlace de github anterior) y en el ejemplo de integración en: https://codesandbox.io/s/react-final-form-material-ui-example-tqv09?file=/src/index.jsx.

	    Una parte importante de los formularios es la validación de entradas, puedes construir un validador a mano y pasárselo al componente material-ui para cachar cosas muy específicas, eso es más o menos laborioso.

	    Por eso tenemos otra librería (¬_¬).

	    Yup (https://github.com/jquense/yup) es un constructor de esquemas de 'parsing' y validación, y es fácilmente integrable con mui-rff.

	   	Lo instalas con:

	   		yarn add yup @types/yup

	    La cosa se ve así:

	    	import { Form } from 'react-final-form';
			import { makeValidate } from 'mui-rff'; //importante
			import * as Yup from 'yup';

			// We define our schema based on the same keys as our form:
			const schema = Yup.object().shape({
			  employed: Yup.boolean().required(),
			});

			// Run the makeValidate function...
			const validate = makeValidate(schema);

			// Then pass the result into the <Form/>...
			<Form validate={validate}>
			  <Checkboxes name="employed" required={true} data={{ label: 'Employed', value: true }} />
			</Form>

		Y ya tienes bien validado tu formulario (en el front, no te olvides de validar en el backend).

		SOBRE ERRORES EN POST AXIOS
		La request generada dió muchos problemas. El detalle estaba en el número de teléfono, lo descubrí agregando err.response al catch de la request (https://stackoverflow.com/questions/60120909/axios-400-bad-request-in-react):

			const onSubmit = async values => {
		        const fName = values.firstName;
		        const lName = values.lastName;
		        const uPhone = values.phone;
		        const uMail = values.email;

		        const body = {
		            "name": {
		                "first": fName,
		                "last": lName
		            },
		            "phone": uPhone,
		            "email": uMail
		        };

		        // console.log(body);
		        client.post(url, body)
		        .then(
		            window.alert("Contact added")
		        )
		        .catch(err => console.log(err.response));//aquí mero XD
    		}

    	Feathers solo acepta números así: +5555555555 (diez dígitos y el +). Hay que editar la expresión regular de Yup para el teléfono, pero fuera de eso, todo va bien, ya se inserta en la BD (:o), aunque no usamos nada de redux para el formulario, esto cuenta como validación del lado del servidor XD, en realidad feathers hizo todo, atento al definir los modelos, no olvides hacer pruebas de llamadas incorrectas desde postman para cubrir todas las posibilidades.

    		No valida que los correos sean únicos
    		No valida que los teléfonos sean únicos

    	SOBRE UPDATE
    	Originalmente usarías nuevos dispatchs, action creators y casos en la función reducer, pero como cambiamos por completo la forma en que el formulario de alta funciona, no se va a poder, de nuevo estamos en aguas desconocidas.

	    	Lo primero a lograr es que el formulario pueda recibir argumentos y pintarlos en los campos
	    		Para eso ocupas el componentDidMount en UpdateContactForm, se ve así en el código:

	    		  componentDidMount() {
				    const _id = this.props.contactId; //recibes el id por las props
				    client.get(url+'/'+_id) //llamas el get de axios para el id especificado
				    	//por algún motivo extraño (de scope probablemente), es necesario que uses
				    	//una arrow function en el then ( response )=>{ //yoyoyo } IMPORTANTE
				        .then((response) => {
				        	//construyes el objeto que va a llenar los campos
				            const contactData = {
				                firstName: response.data.name.first,
				                lastName: response.data.name.last,
				                phone: response.data.phone,
				                email: response.data.email
				            }

				            //pasas el id y el objeto al estado, para poder usarlo en todo el componente
				            this.setState({ data: contactData, contactId : _id })
				        })
				        .catch(function (error) {
				            // handle error
				            console.log(error);
				        })
				  }

	    	Luego que pueda detectar si se trata de un update (o de plano hacer otro componente ad hoc (ulala, don latino XD)).
	    		Usamos otro componente, la card llama a <Link to= { "/contacts/edit/"+ contact._id } ><Button size="small">Edit</Button></Link>
	    		en App.js la ruta para este caso es:
	    			        <Route path="/contacts/edit/:_id" component={UpdateContactFormPage}/>

	    		UpdateContactFormPage cacha el id desde su ruta con:
	    			const { _id } = this.props.match.params; //IMPORTANTE
	    		
	    		y se lo pasa al form así 
	    				<UpdateContactForm contactId={_id}/>

	    		El form lo cacha en el componentDidMount() especificado antes.

	    	Luego hacer el update
	    		Eso va en el onSubmit de UpdateContactForm

	    		const onSubmit = async values => {
	    			//los valores de los campos en el form
			        const fName = values.firstName;
			        const lName = values.lastName;
			        const uPhone = values.phone;
			        const uMail = values.email;

			        //construyes el cuerpo de la request
			        const body = {
			            "name": {
			                "first": fName,
			                "last": lName
			            },
			            "phone": uPhone,
			            "email": uMail
			        };

			        //nota el put url/id, body, así le dices a axios que llame a la api
			        // y que actualize el registro con id = contactId con los datos de body
			        client.put(`${url}/${this.state.contactId}`, body)
			        .then(
			            window.alert("Contact has been updated")
			        )
			        .catch((err) => { window.alert("There was an error, please check your input"); console.log(err.response) } );
			    }

			Y yaaaaaa, así queda el update, ahora sigue el delete.

		SOBRE DELETE
			Las card van a hacer todo el trabajo en el front en este caso.

			Recordarás que para construirlas vamos así:

			Primero App.js llama a ContactListPage.js en la ruta '/', este componente importa los dispatch ya listos para ser llamados desde contact-actions.js, ejecuta el que trae todos los contactos de la BD y se los pasa junto al dispatch del delete (este es nuevo) a la fábrica de tarjetas que es contact-list.js, nota que usa mapDispatchToProps para poder hacerlo (después de todo son dispatchs lol, revisa la documentación para la función 'connect' en redux).

			El dispatch del delete se ve así (va en contact-actions.js):

				export function deleteContact(_id) {
				    return dispatch => {
				      return dispatch({
				        type: 'DELETE_CONTACT',
				        payload: client.delete(`${url}/${_id}`)
				      })
				    }
				}

			La fábrica de tarjetas le pasa los datos de cada contacto y el dispatch del delete a cada nueva card.

			Por último se actualizan las cards para que en el botón de borrar se llame al dispatch del delete con el id del contacto que está pintando.

				<Button size="small" 
                    onClick={ () => deleteContact(contact._id) }
                >
                    Delete
                </Button>

            Llamar al dispatch que está enlazado con el store (por el connect en ContactListPage, atento ahí, esa vaina es importante), llama a la API que hace el delete y en su response se activa la función reducer (en contact-reducer.js) que ahora incorpora las posibles respuestas en el switch.

            	//esto es lo que devuelve client.delete(`${url}/${_id}`) cuando todo sale bien, si no es así se va al default del switch ;).
            	case 'DELETE_CONTACT_FULFILLED': {
		          const _id = action.payload.data._id;
		          return {
		            ...state,
		            contacts: state.contacts.filter(item => item._id !== _id)
		          }
		        }

		    Y así queda el delete.

	Y así queda la integración del front y el back

Y así queda el proyectooooo (aún falta acomodar colores y layouts, pero la funcionalidad ya quedó :D)

Comandos
	MONGODB
	DB run: "C:\Program Files\MongoDB\Server\4.4\bin\mongod.exe" --dbpath="c:\data\db"
	
	API
	API test: Consola en \backend, "yarn test" (lol)
	API run: Consola en \backend, "yarn start"

	REACT
	Start APP: Consola en \, "yarn start"

	GIT
	Stage all changes: 'git add .'
	Commit staged changes: 'git commit -m "mensajeeee"'
	Update repo: 'git push origin master'