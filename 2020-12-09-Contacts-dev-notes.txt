09/12/2020
Jajaja, perdí todas las notas anteriores (no me voy a acordar de todo T.T), porque borré todo el proyecto debido a que no jalaba (sospecho de la selección del lint-er) así que vamos a ver de qué va esta vaina.

REFLEXIONES SOBRE PROYECTOS REACT-FEATHERS-MONBODB
Normalmente harías una API con Express, en ese caso tendrías que armar los famosos modelos, sus métodos (lo que le hacen a la BD) y los endpoints asociados a los métodos para activar su función en la BD (un CRUD).

Pues Feathersjs acelera ese proceso 'a la' Laravel, ya ves que le pasabas la BD, los nombres de los modelos y ya solito hacía todo el crud de manera automática.

Entonces, 'recableando' un poco puedes usarlo para tu BD.

MongoDB es una BD que funciona con archivos, supongo guarda las cosas en algo parecido a JSON, ammm, pues lo instalas y así (https://docs.mongodb.com/manual/tutorial/install-mongodb-on-windows/).

También debes instalar feathersjs (https://docs.feathersjs.com/) y oooobviamente tener node, react y yarn (opcional) instalados.

Estuve peleándome full con las versiones del Node y el condenado Yarn que quiere checar todo (tal vez no fué la mejor idea instalarlo lol), pero ya quedó, sospecho que el proyecto anterior no jaló debido a que ejecuté el create-react-app antes de instalar yarn y por eso el 'yarn start' no jalaba, pero ahora sí.

BTW, yarn es un package manager (https://yarnpkg.com/), es decir una capa más al ya atascado de capas proceso de creación de apps (a veces no le veo sentido jaja, y en realidad es una herramienta pensada para proyectos con muchos módulos, dependencias y así por el estilo).

11/12/2020
Pasos 2.8, 2.9, y 2.10, funcionó (lol), falta construir el front :s.

12-14/12/2020
Pasos 3.1 y 3.2, yasta, falta redux :ss.

15-22/12/2020
Revisión de notas sobre redux, y pasos 4.1 y 4.2, estamos listos para llenar los archivos de redux.

23-25/12/2020
Archivos para redux y sus dependencias.

26-29/12/2020
Conectar redux y react, la conexión está lista.

SUMARIO PROYECTO CONTACTOS
	1. Crea el proyecto con create-react-app

	2. Crear API
		2.1 Instalar gobalmente feathers-cli
		
		2.2 Crear carpeta llamada 'backend' (o cualquier nombre lol) y mover la terminal a ese directorio
		
		2.3 Crear el servidor con 'feathers generate app' //Nota que aquí eliges el linter, elegí ESLint y mocha para testing (ni idea de qué sea mocha lol)
		
		2.4 Crear rutas y modelos para los contactos (a la Laravel) con 'feathers generate service' //eliges mongoose, contact, /contacts y mongodb://localhost:27017/backend
		
		2.5 Instalar extensión para validar emails con 'yarn add mongoose-type-email'
		
		2.6 Instalar nodemon para no tener que reiniciar el servidor cuando modifiques algo con 'yarn add nodemon --dev'
		
		2.7 Modificar backend/package.json en la línea start a "nodemon src/"
			"scripts": {
			    "test": "yarn run lint && yarn run mocha",
			    "lint": "eslint src/. test/. --config .eslintrc.json --fix",
			    "dev": "nodemon src/",
			    "start": "node src/", /* se pasa a => "nodemon src/" */
			    "mocha": "mocha test/ --recursive --exit"
			  },
		
		2.8 Configurar la conexión a la BD en /backend/config/default.json
		
		2.9 Configurar modelos, para contact defines las propiedades que tendrán los "objetos" contacto, a saber: nombre, email, teléfono y fechas de creación y última modificación, esto se hace en backend/srs/models/contact.model.js (ese es el modelo que se creó con 'feathers generate service', revísalo en el commit para ver cómo quedó)
		
		2.10 Ya puedes testear el endpoint para 'contacts' en 'http://localhost:3030/contacts', y si le pasas un POST con los datos adecuados (con postman) los crea en la BD (:o, feathers simplifica full las cosas XD), estamos listos para hacer el front-end y llamar a los endpoints desde react.

		El cuerpo de la request debe llevar esto:

			{
			  "name": {
			    "first": "Joe",
			    "last": "BTO"
			  },
			  "phone": "+5555555555",
			  "email": "joe@merengues.com"
			}

		Notas sobre API: Con un comando ('generate service'), Feathers hace todo el trabajo para armar un modelo y su CRUD (revisa su documentación), obviamente hay que hacer cambios (véase punto 2.10) pero ya te ayuda con buena parte del trabajo.
		Puedes agregar tantos servicios, modelos y funciones como necesites, aunque para efectos didácticos (supongo), el libro solo muestra este ejemplo, de todos modos basta para hacer los demás si hacen falta, aquí termina la sección de la API.

	3. Crear Front-End
		3.1 Instalar dependencias para front-end (supongo son una especie de bootstrap para react, yeiii, una capa más ahora sobre la sintáxis al crear componentes T.T, por cierto que instalas en la raíz del proyecto (no en /backend))
			3.1.1 Instalar SemanticUI con 'yarn add semantic-ui-react semantic-ui-css' (https://react.semantic-ui.com/usage)
			3.1.2 Instalar react-router (lo usamos en el clon de reddit) con 'yarn add react-router-dom' (https://reactrouter.com/web/guides/quick-start)
		
		3.2 Agregar componentes para mostrar los contactos (un 'reporte') y para recibirlos/guardarlos (un 'insert/update').

		Notas sobre Front-End: El código modificado en el commit del 15/12 literal fué un copy paste (lol) lo revisé y puse algunas notas en App.js.

		3.3 Instalar Redux (para gestión del estado, https://redux.js.org/introduction/getting-started), redux-promise-middleware (para ahorrarte trabajo con el 'handling' de los action, https://www.npmjs.com/package/redux-promise-middleware) y redux-thunk (para hacer solicitudes asíncronas a la API, https://github.com/reduxjs/redux-thunk)
			yarn add redux react-redux redux-promise-middleware redux-thunk 
		
		3.4 Para hacer las requests vamos a usar Axios(https://www.npmjs.com/package/axios) y para supervisar el comportamiento del store y las llamadas a 'dispatch' usaremos redux-devtools (https://www.npmjs.com/package/redux-devtools-extension, también instala su extensión en tu browser)
			yarn add redux-devtools-extension axios
		
		3.5 Crear archivos para ingregar redux con react
			contact-data.js /*Tiene un array (llamado 'contacts') con objetos 'contacto' (id, name, phone, email), ahorita está hardcodeado para hacer pruebas*/
			
			actions/contact-actions.js /*Exporta una función (fetchContacts()) que puede ser llamada asíncronamente para traerse los valores de contact-data y pasarlos al reducer (reducers/contact-reducer), incluye el action creator y el dispatch, solo hay que llamarla*/
			
			reducers/contact-reducer /*Función reducer para los contactos, el primer caso es el que cacha el action type FETCH_CONTACTS, que concatena al estado los valores que retorne la función fetchContacts()*/

			reducers/index.js /*concatena los reducers y los exporta listos para pasarlos al store*/

			store.js /* Creación del store */

			index.js /* Agregar store al componente <App/> para poder usarlo en todos lados*/

		4. Cablear Front-end y Back-end

			AQUÍ VAS


		Notas sobre integración:
		
			SOBRE REDUX
			Redux es un framework de administración de estado para aplicaciones javascript. En redux tienes solo un contenedor de estados (store) para toda la aplicación (y solo uno). 

			Al ser un administrador de estado, redux puede lidiar con la modificación de una parte del estado (e.g. cambiar el teléfono de un usuario). En redux, todos los cambios de estado son efectuados al enviar (dispatch) una acción (action) al store (contenedor del estado).

			Las actions pueden verse como 'mensajeros' que llevan la información de los eventos que suceden en la app al store, luego, el store se encarga de actualizar su estado en función del 'mensaje' de la action. Los action son objetos que deben llevar la llave 'type' y opcionalmente más datos.

				const action = {
				  type: 'LOGIN'
				}

			para pasarlos al store (y que pueda encargarse de los cambios) se usan los 'action creators'. Un action creator es una función que retorna un action. 

				// Action creator
				function actionCreator(){ return action };

			luego usas el método 'dispatch' del store para entregárselo y que haga la operación sobre el estado indicada por el valor de la llave 'type' del action.

				const store = Redux.createStore(
				  (state = {login: false}) => state
				);
				const loginAction = () => {
				  return {
				    type: 'LOGIN'
				  }
				};
				// Dispatch the action here:
				store.dispatch(loginAction());

			Una vez hecho el dispatch, el store debe saber qué hacer con el 'action' indicado, para eso se usan los 'reducer', un reducer es una función pura (no cambia nada en términos globales, solo sus argumentos) que recibe un 'state' un 'action' y retorna un nuevo 'state'. 

			Las funciones reducer siempre deben retornar una nueva versión del estado y nunca modificarlo directamente.

			  const defaultState = {
			    authenticated: false
			  };//state
			  
			  //función reducer, nota cómo recibe el state y puede recibir un action
			  //también tiene un switch con los action que puede recibir y qué hacer en cada caso 
			  const authReducer = (state = defaultState, action) => {
			    switch ( action.type ){
			      case "LOGIN":
			        return {
			          authenticated: true
			        };
			  
			      case "LOGOUT":
			        return {
			          authenticated: false
			        };
			  
			      default:
			        return defaultState;
			    }
			  };
			  
			  //nota que el createStore llama a la función reducer (authReducer)
			  //así cuando llames a 'dispatch' (método del store) ya tienes enlazado el reducer y con él el estado
			  const store = Redux.createStore(authReducer);
			  
			  //action creators
			  const loginUser = () => {
			    return {
			      type: 'LOGIN'
			    }
			  };
			  
			  const logoutUser = () => {
			    return {
			      type: 'LOGOUT'
			    }
			  };

			El store también tiene el método 'subscribe', que llama a una función cada vez que el estado cambia

			  	const ADD = 'ADD';

				const reducer = (state = 0, action) => {
				  switch(action.type) {
				    case ADD:
				      return state + 1;
				    default:
				      return state;
				  }
				};

				const store = Redux.createStore(reducer);

				// global count variable:
				let count = 0;

				// función que incrementa la variable count, aquí puede ir lo que sea lol
				const addOne = () => (count += 1);

				//subscribe de la función addOne al store
				store.subscribe( addOne );

				//cada vez que cambie el estado (véase el 'dispatch') se llama a addOne por el 'subscribe'
				store.dispatch({type: ADD});
				console.log(count);
				store.dispatch({type: ADD});
				console.log(count);
				store.dispatch({type: ADD});
				console.log(count);

			Para lidiar con estados complejos puedes crear múltiples funciones 'reducer' y luego concatenarlas para pasárselas a createStore
			(recuerda que solo puede haber un estado), el método para hacerlo es combineReducers (makes sense lol).

			Es buena práctica crear un reducer por cada pieza del estado que sea distinta de las otras de alguna manera. e.g. En una app de notas con autenticación de usuarios un reducer puede lidiar con la autenticación mientras otro se encarga de las notas (objeto usuario y objeto nota son fundamentalmente distintos, en keys y sus respectivos valores), en ese caso podríamos combinar los reducers así:

				//authenticationReducer y notesReducer son reducers como los declarados en los ejemplos anteriores
				const rootReducer = Redux.combineReducers({
				  auth: authenticationReducer,
				  notes: notesReducer
				});

			Otro ejemplo ;):

				const INCREMENT = 'INCREMENT';
				const DECREMENT = 'DECREMENT';

				const counterReducer = (state = 0, action) => {
				  switch(action.type) {
				    case INCREMENT:
				      return state + 1;
				    case DECREMENT:
				      return state - 1;
				    default:
				      return state;
				  }
				};

				const LOGIN = 'LOGIN';
				const LOGOUT = 'LOGOUT';

				const authReducer = (state = {authenticated: false}, action) => {
				  switch(action.type) {
				    case LOGIN:
				      return {
				        authenticated: true
				      }
				    case LOGOUT:
				      return {
				        authenticated: false
				      }
				    default:
				      return state;
				  }
				};

				/*Aquí combinas los reducers como elementos del nuevo reducer
				  nota que las const que los contienen nunca son llamadas por createStore
				*/
				const rootReducer = Redux.combineReducers(
				  {
				    count: counterReducer,
				    auth: authReducer
				  }
				);

				const store = Redux.createStore(rootReducer);

			También puedes pasarle parámetros a los reducers para hacer cosas como handling de entrada de usuario y así.

				const ADD_NOTE = 'ADD_NOTE';

				const notesReducer = (state = 'Initial State', action) => {
				  switch(action.type) {
				    /* Se cacha la acción y se retorna el dato (léase entrada de usuario) como prop del parámetro action
				       véase action.text */
				    case ADD_NOTE:
				    	return  action.text

				    default:
				    	return state;
				  }
				};

				const addNoteText = (note) => {
				  return {type: ADD_NOTE, text: note}; //el action creator retorna la action tipo ADD_NOTE y pasa un parámetro al reducer
				};

				const store = Redux.createStore(notesReducer);

				console.log(store.getState());
				store.dispatch(addNoteText('Hello!')); //le pasas al action creator un parámetro ('Hello!')
				console.log(store.getState());

		Eventualmente vas a necesitar hacer llamadas asíncronas a algún recurso (sea una BD, una API, o por el estilo), para lograrlo vas a necesitar un 'middleware' diseñado para ese propósito, en este caso usaremos 'Redux Thunk'

		Para incluir 'Redux Thunk' al store, lo pasas como argumento al método applyMiddleware() y a su vez, lo agregas como segundo parámetro a createStore().

			const store = Redux.createStore(
			  asyncDataReducer, //la función reducer
			  Redux.applyMiddleware(ReduxThunk.default) //segundo parámetro con el middleware redux thunk
			);

		Luego, para crear las acciones asíncronas, usas un action creator que retorne una función que reciba 'dispatch' como argumento (lol), dentro de esa función puedes hacer dispatch a otras acciones y hacer solicitudes asíncronas a los recursos de terceros.

			//action creator que retorna una función que recibe dispatch como argumento
			const handleAsync = () => {
			  return function(dispatch) {
			    // dispatch request action here
			    dispatch(requestingData()); //recuerda que los dispatch reciben action creators con la llave 'type'
			    							// lo que le permite saber al reducer qué hacer con el estado

			    setTimeout(function() {
			      //el setTimeout simula la solicitud asíncrona que devuelve los valores de 'data'
			      let data = {
			        users: ['Jeff', 'William', 'Alice']
			      }
			      dispatch(receivedData(data)); //llamas a dispatch y le pasas un action creator distinto
			      								//en este caso puede ser el que actualiza el estado para pintar a 'data'
			      								//nota que le pasa 'data' como parámetro, lo que indica que el reducer va a usar esos datos
			    }, 2500);
			  }
			};

		SOBRE EL CREATE STORE DEL PROYECTO
		Usamos redux dev tools, en su documentación está este ejemplo de configuración inicial:

			import { createStore, applyMiddleware } from 'redux';
			import { composeWithDevTools } from 'redux-devtools-extension';

			const store = createStore(reducer, composeWithDevTools(
			  applyMiddleware(...middleware),
			  // other store enhancers if any
			));

		Y es más o menos lo que el libro traía:

			import { applyMiddleware, createStore } from "redux";
			import thunk from "redux-thunk";
			import promise from "redux-promise-middleware";
			import { composeWithDevTools } from "redux-devtools-extension"
			import rootReducer from "./reducers";

			const middleware = composeWithDevTools(applyMiddleware(promise(),thunk))

			export default createStore(rootReducer,middleware);

		Nota la constante middleware que con composeWithDevTools() invoca los middleware que vamos a usar; promise y thunk,
		luego se los pasa createStore() como segundo argumento, el primero es el stack de reducers de reducers/index.js (nota el import
		que no especifica la ruta completa, solo la carpeta './reducers', :o)

		Por cierto que el código da error XD, debes quitarle los paréntesis a 'promise()' para que funcione, en la documentación de redux-promise-middleware (https://github.com/pburtchaell/redux-promise-middleware/blob/HEAD/docs/introduction.md) está:

			import promise from 'redux-promise-middleware'

			composeStoreWithMiddleware = applyMiddleware(
			  promise,
			)(createStore);

		Que es otra sintáxis para crear stores, pero lo que nos interesa es que el argumento 'promise' de applyMiddleware no lleva los paréntesis de función, probé a quitárselos en el código y jaló :).

		SOBRE EL 'SPREAD OPERATOR'
		Es una 'sintáxis' que permite invocar todos los elementos de un elemento iterable (léase array o string), y modificarlo (o no) uno por uno.

		Es usada comúnmente para agregar un nuevo elemento a un contenedor de datos local (de nuevo un array) o pintar todos los valores del array
		más (+) un nuevo elemento.

		Un ejemplo (muy simple) de esto es:

			let numberStore = [0, 1, 2];
			let newNumber = 12;
			numberStore = [...numberStore, newNumber];
			//numberStore ahora es [0,1,2,12]

		Cada vez que llames la sintaxis con el spread operator (los tres puntos antes del nombre del array e.g.: ...numberStore)
		se va a agregar un 12 al final del array.

		Nota que se tuvo que hacer la asignación de numberStore a lo que retorne el 'spread operator', pues no modifica el array original
		(por eso se lleva bien con redux y la programación funcional en general).

		SOBRE CABLEADO REACT-REDUX
		En index.js habíamos habilitado redux como 'wrapper' de la app (el componente <Provider store={store}>), pero necesitas especificar qué partes del state y qué actions vas a ocupar en cada componente, para eso están las funciones mapStateToProps() y mapDispatchToProps(),

			function mapStateToProps( state ){
			   //Se recibe el state como argumento y se pasa como valor de la llave messages
			   //nota que solo es así para este caso, en teoría podrías decidir qué partes
			   //del state vas a pasar como props al componente
			  return { messages: state };
			}

		mapDispatchToProps(), Es usada para pasarle 'action creators' específicos a los componentes react para que puedan hacer sus dispatch asociados al store. Retorna un objeto que mapea los dispatch con props de componente react (de ahí el nombre lol), pero en vez de regresar una parte del estado (como mapStateToProps), cada prop retorna una función que llama el dispatch con su action creator y cualquier dato (argumento) necesario. 

			//La función recibe dispatch, para poder pasárlo a las props y que el componente pueda llamarlo
			function mapDispatchToProps( dispatch ){
			  //Va a regresar un objeto con la prop submitNewMessage (que será llamada desde el componente)
			  //y recibe el argumento(parámetro) message que a su vez ejecuta el dispatch (definido en otro lado XD)
			  return {
			  	submitNewMessage: function (message) {
			      					dispatch( addMessage(message) );
			    				  } 
			  };
			}

		Ahora con las funciones listas, puedes pasárselas a un componente react para que las use y así conectar react y redux (al fin XD), para eso sirve el método 'connect()' de redux (naturalmente tienes que importarlo), este método recibe tres argumentos, los primeros dos opcionales que son mapStateToProps y mapDispatchToProps, el tercero es el componente, los 'map' son opcionales porque puede que necesites un componente que solo traiga cosas del estado pero no dispatch o visceversa. La sintáxis eso sí, es un tanto atípica:

			 connect(mapStateToProps, mapDispatchToProps)(MyComponent)

		Si quieres omitir uno de los argumentos opcionales pasas 'null' en su lugar.

		Todo en un ejemplo se vería así:


		//Action creator
		const addMessage = (message) => {
		  return {
		    type: 'ADD',
		    message: message
		  }
		};

		//función mapstatetoprops (duh), para pasar el estado como una prop al componente
		const mapStateToProps = (state) => {
		  return {
		    messages: state
		  }
		};

		//función mapdispatchtoprops (duh again), para pasar actions como una prop al componente
		const mapDispatchToProps = (dispatch) => {
		  return {
		    submitNewMessage: (message) => {
		      dispatch(addMessage(message));
		    }
		  }
		};

		//definición del componente
		class Presentational extends React.Component {
		  constructor(props) {
		    super(props);
		  }
		  render() {
		    return <h3>This is a Presentational Component</h3>
		  }
		};

		const connect = ReactRedux.connect;

		//Conectando el componente, es importante pasarlo a una variable
		const ConnectedComponent = connect(mapStateToProps, mapDispatchToProps)(Presentational);

		Y ahora puedes usar las props definidas en las funciones map. Así puedes pintar datos en función del store redux y modificar el store desde el componente ;).

		SOBRE VALIDACIÓN DE TIPOS PARA PROPS
		En el libro a veces se valida que las props pasadas a un componente tengan ciertas propiedades (e.g. que la prop sea un objeto y que es requerida), googleando la sintáxis, la forma de hacer esto ha cambiado (https://es.reactjs.org/docs/typechecking-with-proptypes.html.

		Ahora debes instalar prop-types, (una más T.T).

			npm install --save prop-types
			yarn add prop-types

		Luego la importas al componente

			import PropTypes from 'prop-types'; // ES6

		Y ya la puedes usar (véase la documentación, https://www.npmjs.com/package/prop-types).

Comandos
	MONGODB
	DB run: "C:\Program Files\MongoDB\Server\4.4\bin\mongod.exe" --dbpath="c:\data\db"
	
	API
	API test: Consola en \backend, "yarn test" (lol)
	API run: Consola en \backend, "yarn start"
	APP run: Consola en \, "yarn start"

	REACT
	Start APP: Consola en \, "yarn start"

	GIT
	Stage all changes: 'git add .'
	Commit staged changes: 'git commit -m "mensajeeee"'
	Update repo: 'git push origin master'